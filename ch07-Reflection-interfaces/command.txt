Рефлексия (Отражения) и интерфейсы на все случаи жизни

----------------------------------------------------------
Методы типов    method.go

    Метод типа (type method) в Go — это функция со специальным аргументом-при-
    емником. Такой метод объявляется как обычная функция с дополнительным
    параметром, который ставится перед именем функции. Данный параметр связы-
    вает функцию с типом этого дополнительного параметра. Именно этот параметр
    называется приемником метода.

    func (f *File) Close() error {
        if err := f.checkValid("close"); err != nil {
            return err
        }
        return f.file.close()
    }

    type twoInts struct {X int64 Y int64}
    func regularFunction(a, b twoInts) twoInts {
        temp := twoInts{X: a.X + b.X, Y: a.Y + b.Y}
        return temp
    }
    func (a twoInts) method(b twoInts) twoInts {
        temp := twoInts{X: a.X + b.X, Y: a.Y + b.Y}
        return temp
    }
        i := twoInts{X: 1, Y: 2}
        j := twoInts{X: -5, Y: -2}
        fmt.Println(regularFunction(i, j))
        fmt.Println(i.method(j))


----------------------------------------------------------
Интерфейсы в Go

    Интерфейсный тип в Go определяет поведение других типов путем предоставле-
    ния списка методов, которые необходимо реализовать. Чтобы тип соответствовал
    интерфейсу, в нем необходимо реализовать все методы, предусмотренные этим
    интерфейсом

    Проще говоря, интерфейс — это абстрактный тип, определяющий множе-
    ство функций, которые необходимо реализовать для типа, чтобы его можно
    было считать экземпляром интерфейса. Если это сделано, можно сказать, что
    тип удовлетворяет данному интерфейсу. Таким образом, интерфейс — это две
    составляющие: набор методов и тип. Интерфейс используется для определения
    поведения других типов.

    io.Reader и io.Writer
    type Reader interface {
        Read(p []byte) (n int, err error)
    }
    type Writer interface {
        Write(p []byte) (n int, err error)
    }

----------------------------------------------------------
Операции утверждения типа    assertion.go   myInterface.go   useInterface.go

    Операции утверждения типа — это записи вида x.(T), где x — интерфейсный тип, а T — тип

    var myInt interface{} = 123
    k, ok := myInt.(int)
    if ok {
        fmt.Println("Success:", k)
    }

    $ mkdir ~/go/src/myInterface
    $ cp myInterface.go ~/go/src/myInterface
    $ go install myInterface

----------------------------------------------------------
Использование интерфейса Go    useInterface.go

    func (s circle) Area() float64 {
        return s.R * s.R * math.Pi
    }
    func (s circle) Perimeter() float64 {
        return 2 * s.R * math.Pi
    }
    func Calculate(x myInterface.Shape) {
        _, ok := x.(circle)
        if ok {
            fmt.Println("Is a circle!")
        }
        v, ok := x.(square)
        if ok {
            fmt.Println("Is a square:", v)
        }
        fmt.Println(x.Area())
        fmt.Println(x.Perimeter())
    }

    Как видим, в этом коде реализована функция, для которой требуется один пара-
    метр типа shape, — myInterface.Shape. Эта магия станет более очевидной, когда вы
    поймете, что здесь подойдет любой параметр типа shape, то есть любой параметр,
    тип которого реализует интерфейс shape

    x := square{X: 10}
    fmt.Println("Perimeter:", x.Perimeter())
    Calculate(x)
    y := circle{R: 5}
    Calculate(y)


----------------------------------------------------------
Использование переключателей для интерфейсов и типов данных    switch.go

    type rectangle struct {
        X float64
        Y float64
    }
    func tellInterface(x interface{}) {
        switch v := x.(type) {
        case square:
            fmt.Println("This is a square!")
        case circle:
            fmt.Printf("%v is a circle!\n", v)
        case rectangle:
            fmt.Println("This is a rectangle!")
        default:
            fmt.Printf("Unknown type %T!\n", v)
        }
    }
        y := rectangle{X: 4, Y: 1}
	    tellInterface(y)


----------------------------------------------------------
----------------------------------------------------------
Рефлексия (Отражения)

    Рефлексия — это дополнительная функциональность Go, которая позволяет дина-
    мически, в процессе выполнения программы, узнавать тип произвольного объекта,
    а также получать информацию о его структуре. Для работы с рефлексией в Go
    создан пакет reflect

----------------------------------------------------------
Простой пример рефлексии   reflection.go

    x := 100
	xRefl := reflect.ValueOf(&x).Elem()
	xType := xRefl.Type()
    =
    xType := reflect.TypeOf(x)

    var r reflect.Value
    r = reflect.ValueOf(&A).Elem()
        Типом переменной r должен быть reflect.Value, по-
        скольку функция reflect.ValueOf() возвращает значение именно этого типа. Метод
        Elem() возвращает значение, содержащееся в интерфейсе рефлексии (reflect.Value)

    iType := r.Type()
    for i := 0; i < r.NumField(); i++ {
        fmt.Printf("Field name: %s ", iType.Field(i).Name)
        fmt.Printf("with type: %s ", r.Field(i).Type())
        fmt.Printf("and value %v\n", r.Field(i).Interface())
    }
    функции пакета reflect: 
    Метод NumField() возвращает количество полей в структуре reflect.Value, а 
    функция Field() возвращает поле структуры, переданной ей в качестве параметра. 
    Функция Interface() возвращает значение поля структуры reflect.Value в качестве интерфейса

    $ go run reflection.go 1
    $ go run reflection.go

----------------------------------------------------------
Более сложный пример рефлексии    advRefl.go

    type t1 int
    type t2 int
        для Go t1 и t2 - это разные типы
        Их внутреннее представление будет main.t1 и main.t2 соответственно

    func (a1 a) compareStruct(a2 a) bool {
        r1 := reflect.ValueOf(&a1).Elem()
        r2 := reflect.ValueOf(&a2).Elem()
        for i := 0; i < r1.NumField(); i++ {
            if r1.Field(i).Interface() != r2.Field(i).Interface() {
                return false
            }
        }
        return true
    }

    func printMethods(i interface{}) {
        r := reflect.ValueOf(i)
        t := r.Type()
        fmt.Printf("Type to examine: %s\n", t)
        for j := 0; j < r.NumMethod(); j++ {
            m := r.Method(j).Type()
            fmt.Println(t.Method(j).Name, "-->", m)
        }
    }
        a1 := a{1, 2.1, "A1"}
        a2 := a{1, -2, "A2"}
        if a1.compareStruct(a1) {
            fmt.Println("Equal!")
        }
        if !a1.compareStruct(a2) {
            fmt.Println("Not Equal!")
        }
        var f *os.File
        printMethods(f)

----------------------------------------------------------
Три недостатка рефлексии

    код становится трудно читать и поддерживать
    код Go, в котором используется рефлексия, замедляет выполнение программы
    ошибки рефлексии не распознаются на этапе сборки и обнаруживаются только в процессе выполнения, вызывая панику


----------------------------------------------------------
Библиотека reflectwalk    walkRef.go

    Библиотека reflewalk позволяет перебирать сложные значения в Go, используя
    рефлексию, — подобно тому как мы перебираем файлы в файловой системе

    func (t *WalkMap) Map(m reflect.Value) error {
        t.MapVal = m
        return nil
    }
    Интерфейс, определеннный в reflewalk, требует реализации функции Map(),
    которая используется для поиска в хеш-таблицах

    $ go mod init useV1V2
    $ go get github.com/mitchellh/reflectwalk
    $ go run walkRef.go


----------------------------------------------------------
----------------------------------------------------------
Объектно-ориентированное программирование на Go     ooo.go   goCoIn.go

    Как вы уже знаете, в Go не используется наследование — вместо этого язык под-
    держивает композицию. Интерфейсы Go обеспечивают своего рода полиморфизм.
    Таким образом, хотя Go и не является объектно-ориентированным языком, не-
    которые его возможности позволяют имитировать объектно-ориентированное
    программирование.

    В первом случае используются методы, позволяющие ассоциировать функцию с типом

    Второй прием позволяет встраивать тип
    в новый структурный тип, чтобы создать своего рода иерархию

    Третий прием, в котором с помощью интерфейса Go можно создать 
    несколько элементов — объектов одного и того же класса

    $ go run ooo.go
    $ go run goCoIn.go

    j.F() по-прежнему вызывает first.shared(), а не second.shared()
    вызов j.F() может быть записан как (i.first).F() или как (second{}.first).F()


----------------------------------------------------------
----------------------------------------------------------
Основы git и GitHub

----------------------------------------------------------
Использование git

    перенести существующий репозиторий GitHub на локальный компьютер
    нужно использовать команду git clone

    git status показывает состояние рабочего дерева

    git pull используется для получения обновлений из удаленного репозитория

    новые файлы нужно сначала добавить в репозиторий с помощью команды git add

    git commit предназначена для записи изменений в репозиторий

    git push, чтобы передать изменения в удаленный репозиторий

----------------------------------------------------------
Работа с ветками

    Чтобы создать на локальном компьютере новую ветку с именем new_branch
    и перейти к ней, нужно использовать следующую команду:
    $ git checkout -b new_branch

    Если вы хотите подключить эту ветку к GitHub, следует выполнить такую команду:
    $ git push --set-upstream origin new_branch

    Если вы хотите перейти с текущей ветки на основную ветку, то нужно выпол-
    нить следующую команду:
    $ git checkout master

    Для того чтобы удалить локальную ветку — в данном случае new_branch, — нуж-
    но выполнить команду git branch -D:
    $ git --no-pager branch -a
        * master
        new_branch
        remotes/origin/HEAD -> origin/master
        remotes/origin/master
        remotes/origin/new_branch
    $ git branch -D new_branch
        Deleted branch new_branch (was 98f8a77).
    $ git --no-pager branch -a
        * master
        remotes/origin/HEAD -> origin/master
        remotes/origin/master
        remotes/origin/new_branch

----------------------------------------------------------
Работа с файлами

    Для того чтобы удалить файл a_file.go, нужно сделать следующее:
    $ rm a_file.go
    $ git rm a_file.go
        rm 'ch07/a_file.go'

    В .gitignore содержится список файлов и каталогов, которые следует игнори-
    ровать при записи изменений на GitHub

    Команда git diff показывает различия между зафиксированными изменениями
    и рабочим репозиторием, веткой и т. п.

----------------------------------------------------------
Работа с тегами

    Тег — это способ пометить определенную версию кода. Тег можно представить как
    ветку, которая никогда не меняется.
    Чтобы создать легкий тег, нужно выполнить такую команду:
    $ git tag c7.0

    Чтобы получить информацию о конкретном теге, нужно сделать следующее:
    $ git --no-pager show v1.0.0

    Чтобы получить список всех доступных тегов, можно воспользоваться командой git tag:
    $ git --no-pager tag

    Чтобы внести тег в GitHub, нужно сделать следующее:
    $ git push origin c7.0

    Чтобы удалить существующий тег с локального компьютера, нужно выполнить следующую команду:
    $ git tag -d c7.0

    Можно также удалить тег с сервера GitHub:
    $ git push origin :refs/tags/c7.0

----------------------------------------------------------
Команда git cherry-pick

    Команда git cherry-pick — это сложная команда, которую нужно использовать
    осторожно, поскольку она вносит в текущую ветку изменения, зафиксированные
    некоторыми из последних команд git commit. Следующая команда вносит в теку-
    щую ветвь фиксацию номер 4226f2c4:
    $ git cherry-pick 4226f2c4
    Эта команда вносит в текущую ветку все фиксации с 4226f2c4 по 0d820a87, ис-
    ключая фиксацию номер 4226f2c4:
    $ git cherry-pick 4226f2c4..0d820a87
    Данная команда вносит в текущую ветку все фиксации с 4226f2c4 по 0d820a87,
    включая фиксацию 4226f2c4:
    $ git cherry-pick 4226f2c4^..0d820a87


----------------------------------------------------------
----------------------------------------------------------
Отладка с помощью Delve    /debug/main.go

    Delve — это текстовый отладчик программ Go, также написанный на Go. Чтобы
    скачать Delve для macOS Mojave, нужно сделать следующее:
    $ go get -u github.com/go-delve/delve/cmd/dlv
    $ ls -l ~/go/bin/dlv

    (у меня установилось с помощью команды:
    $ go install github.com/go-delve/delve/cmd/dlv@latest)

    $ $GOBIN/dlv version

    Delve — это внешняя программа, то есть для работы Delve
    не нужно подключать какие-либо пакеты к вашим программам Go

    debug. По этой команде Delve компилирует пакет main в текущем рабочем 
    каталоге и начинает его отладку

    $ go mod init debversion
    $ $GOBIN/dlv debug

    Чтобы передать в программу аргументы командной строки, следует запустить Delve так:
    $ $GOBIN/dlv debug -- arg1 arg2 arg3

    $ $GOBIN/dlv debug -- 1 2 3
        Type 'help' for list of commands.
        (dlv)

        c (от continue — «продолжить»)
        r или restart
        break main.main
        break function
        n - next, то отладчик перейдет к следующему оператору
        print i - выводит на экран значение переменной i
        exit (alias: quit | q) ----- Exit the debugger.

    для отладки Go-тестов следует использовать команду dlv test



стр. 363
