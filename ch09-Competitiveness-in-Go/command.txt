Конкурентность в Go: горутины, каналы и конвейеры

----------------------------------------------------------
О процессах, потоках и горутинах

    Процесс — это среда выполнения
    Поток — это меньшая и более легкая сущность, чем процесс или программа
    Горутина — это минимальная сущность Go, которая может быть выполнена конкурентно

----------------------------------------------------------
Планировщик Go

    Планировщик ядра UNIX отвечает за выполнение потоков программы
    в среде выполнения Go есть собственный планировщик
    планированием m:n, при которой m горутин выполняется в n потоках

----------------------------------------------------------
Конкурентность и параллелизм

----------------------------------------------------------
Горутины

----------------------------------------------------------
Создание горутины    simple.go

    func function() {
        for i := 0; i < 10; i++ {
            fmt.Print(i)
        }
    }
    go function()

    go func() {
        for i := 10; i < 20; i++ {
            fmt.Print(i, " ")
        }
    }()

    $ go run simple.go

----------------------------------------------------------
Создание нескольких горутин    create.go

	for i := 0; i < count; i++ {
		go func(x int) {
			fmt.Printf("%d ", x)
		}(i)
	}

    $ go run create.go -n 100

----------------------------------------------------------
Как дождаться завершения горутин, прежде чем закончить программу   syncGo.go

	var waitGroup sync.WaitGroup
	fmt.Printf("%#v\n", waitGroup)
	for i := 0; i < count; i++ {
		waitGroup.Add(1)
		go func(x int) {
			defer waitGroup.Done()
			fmt.Printf("%d ", x)
		}(i)
	}
	fmt.Printf("%#v\n", waitGroup)
	waitGroup.Wait()

    sync.Add() увеличивает счетчик в переменной sync.WaitGroup на единицу
    важно вызвать sync.Add(1) перед оператором go, чтобы предотвратить возможное состояние гонки

    функция sync.Done(), которая уменьшает тот же счетчик на единицу

    Вызов sync.Wait() блокируется до тех пор, пока значение счетчика в соответ-
    ствующей переменной sync.WaitGroup не станет равным нулю, что дает возмож-
    ность всем горутинам завершить работу

    $ go run syncGo.go
    $ go run syncGo.go -n 30

----------------------------------------------------------
Что происходит, если количество вызовов Add() и Done() не совпадает

    fatal error: all goroutines are asleep - deadlock!

    panic: sync: negative WaitGroup counter


----------------------------------------------------------
----------------------------------------------------------
Каналы

    Канал — это механизм коммуникации, который, помимо прочего, позволяет обме-
    ниваться данными между горутинами

    Чтобы создать новый канал, нужно использовать
    ключевое слово chan, а чтобы его закрыть — вызвать функцию close()

----------------------------------------------------------
Запись в канал    writeCh.go

    func writeToChannel(c chan int, x int) {
        fmt.Println(x)
        c <- x
        close(c)
        fmt.Println(x)
    }

    func main() {
        c := make(chan int)
        go writeToChannel(c, 10)
        time.Sleep(1 * time.Second)
    }

    $ go run writeCh.go

    !!! оператор c <- x блокирует выполнение остальной части функции writeToChannel(), 
        так как никто не читает то, что было записанов канал c

----------------------------------------------------------
Чтение из канала    readCh.go

    func writeToChannel(c chan int, x int) {
        fmt.Println("1", x)
        c <- x
        close(c)
        fmt.Println("2", x)
    }

    func main() {
        c := make(chan int)
        go writeToChannel(c, 10)
        time.Sleep(1 * time.Second)
        fmt.Println("Read:", <-c)
        time.Sleep(1 * time.Second)

        _, ok := <-c
        if ok {
            fmt.Println("Channel is open!")
        } else {
            fmt.Println("Channel is closed!")
        }
    }

    $ go run readCh.go
        1 10
        Read: 10
        2 10
        Channel is closed!

----------------------------------------------------------
Прием данных из закрытого канала     readClose.go

	willClose := make(chan int, 10)
	willClose <- 2
	<-willClose    // Empty channel
	close(willClose)
	read := <-willClose
	fmt.Println(read)

    при чтении данных из закрытого канала возвращается нулевое
    значение соответствующего типа

----------------------------------------------------------
Каналы как аргументы функции

    func f1(c chan int, x int) {
        fmt.Println(x)
        c <- x
    }

    func f2(c chan<- int, x int) {
        fmt.Println(x)
        c <- x
    }

    func f1(out chan<- int64, in <-chan int64) {
        fmt.Println(x)
        c <- x
    }

----------------------------------------------------------
----------------------------------------------------------
Конвейеры   pipeline.go

    Конвейер — это виртуальный метод, предназначенный для соединения горутин
    и каналов, так что выходные данные одной горутины становятся входными данны-
    ми для другой горутины, а для передачи данных используются каналы

    $ go run pipeline.go 1 10

----------------------------------------------------------
Состояние гонки    plNoRace.go

    Код pipeline.go неидеален: он содержит логическую ошибку, которая в термино-
    логии конкурентности называется состоянием гонки. Чтобы выявить эту ошибку,
    нужно выполнить следующую команду:

        $ go run -race pipeline.go 1 10

    Чтобы устранить состояние гонки, необходимо использовать сигнальный
    канал и ключевое слово select

	    signal = make(chan struct{})

		if ok {
			signal <- struct{}{}
		} 

		select {
		case <-signal:
			close(out)
			return
		case out <- random(min, max):
		}

    Чтобы узнать, какие изменения мы внесли в pipeline.go, воспользуемся
    командой diff(1) — новая версия программы называется plNoRace.go

        $ diff pipeline.go plNoRace.go

        $ go run -race plNoRace.go 1 10    //  проверить логическую корректность plNoRace.go


----------------------------------------------------------
Сравнение моделей конкурентности в Go и Rust

----------------------------------------------------------
Сравнение моделей конкурентности в Go и Erlang




Стр. 450
