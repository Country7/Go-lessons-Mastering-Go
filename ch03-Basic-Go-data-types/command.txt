Работа с основными типами данных Go

----------------------------------------------------------
Числовые типы данных   numbers.go

Целые числа
  со знаком: int8, int16, int32, int64, кроме того int
  без знака: uint8, uint16, uint32 и uint64, кроме того uint

Числа с плавающей точкой: float32 и float64
Первый из них обеспечивает точность примерно до шестого знака после запятой, 
а второй — до 15-го знака

Комплексные числа: complex64 и complex128
В первом из них используется два типа float32: 
один для вещественной части комплексного числа, 
а второй — для мнимой, 
тогда как в complex128 используется два типа float64.
Комплексные числа выражаются в форме a + bi, где a и b — действительные 
числа, а i — решение уравнения x2(в квадрате) = –1

если разделить одно целое число на другое, то Go решит, что вы хотите 
получить результат целочисленного деления
При преобразовании числа с плавающей запятой в целое число дробь 
отбрасывается путем усечения числа с плавающей запятой до нуля 
знаков после запятой

% - остаток от деления двух чисел (модуль)

    $ go run numbers.go
    Type of c1: complex128
    Type of c2: complex128
    c3: (17+8i)
    Type of c3: complex64
    cZero: (0+0i)
    12
    Type of x: int
    div 2
    m, n: 1.223 0
    y: 1.7391304347826086
    divFloat 2.4
    Type of divFloat: float64


----------------------------------------------------------
Циклы Go

Цикл for
    for i := 0; i < 100; i++ {
        // break
        // continue
    }

    for ok := true; ok; ok = anExpression {
    }

    for condition {}

    range
    anArray := [5]int{0, 1, -1, 2, -2}
    for i, value := range anArray {
        fmt.Println("index:", i, "value: ", value)
    }

Пример применения нескольких циклов Go   loops.go
    $ go run loops.go


----------------------------------------------------------
Массивы в Go:   usingArrays.go
    anArray := [4]int{1, 2, 4, -4}

длина массива len(anArray)

Многомерные массивы:
    twoD := [4][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}
    threeD := [2][2][2]int{{{1, 0}, {-2, 4}}, {{5, -1}, {7, 0}}}

Недостатки массивов Go:
    - если массив определен, вы не можете изменить его размер
    - передавая массив функции в качестве параметра, вы передаете копию массива,
      так что любые изменения, внесенные в массив внутри функции, после выхода 
      из этой функции будут потеряны
    - передача большого массива в функцию — довольно медленная операция
    Решением всех этих проблем является использование срезов Go



----------------------------------------------------------
Срезы в Go

!!! Срезы Go — очень мощные структуры данных. Не будет преувеличением сказать,
    что срезы способны полностью заменить массивы в Go

!!! Срезы передаются в функции по ссылке — это означает, что фактически в функ-
    цию передается адрес памяти переменной среза

инициализация
    aSliceLiteral := []int{1, 2, 3, 4, 5}
    или
    integer := make([]int, 20)

доступ к срезу
    for i := 0; i < len(integer); i++ {
        fmt.Println(integer[i])
    }
    integer[0]  // первый элемент среза
    inte­ger[len(integer)-1]  // последний элемент среза
    integer[1:3]    // второй и третий элемент среза
    s2 := integer[1:3]  // новый (вторичный) срез

очистить срез
    aSliceLiteral = nil

добавить элемент к срезу
    integer = append(integer, 12345)

    $ go run reslice.go
    [0 0 0 0 0]
    [0 0]
    [0 -100 123456 0 0]
    [-100 123456]

!!! При изменении элементов вторичного среза изменяются и элементы исходного среза,
    поскольку оба они указывают на один и тот же базовый массив. Проще говоря, при
    создании вторичного среза не создается копия исходного среза.

----------------------------------------------------------
Автоматическое расширение срезов   lenCap.go

len()  Длина среза
cap()  Емкость среза
append()  добавить элемент к срезу

    $ go run lenCap.go
    aSlice: -1 0 4 
    Cap: 3, Length: 3
    aSlice: -1 0 4 -100 
    Cap: 6, Length: 4
    -1 0 4 -100 -2 -3 -4 
    Cap: 12, Length: 7

!!! Если длина и емкость среза имеют одинаковые значения, то попытка
    добавить в срез еще один элемент приводит к тому, что емкость среза будет
    удвоена, тогда как его длина увеличится только на единицу

!!! Нужно заметить, что емкость среза удваивается, только пока его длина не превысит
    1024 элементов. Далее она растет не более чем на 25 %

----------------------------------------------------------
Функция copy()   copySlice.go

стр. 135



