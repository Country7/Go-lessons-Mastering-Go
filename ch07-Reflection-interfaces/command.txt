Рефлексия и интерфейсы на все случаи жизни

----------------------------------------------------------
Методы типов    method.go

    Метод типа (type method) в Go — это функция со специальным аргументом-при-
    емником. Такой метод объявляется как обычная функция с дополнительным
    параметром, который ставится перед именем функции. Данный параметр связы-
    вает функцию с типом этого дополнительного параметра. Именно этот параметр
    называется приемником метода.

    func (f *File) Close() error {
        if err := f.checkValid("close"); err != nil {
            return err
        }
        return f.file.close()
    }

    type twoInts struct {X int64 Y int64}
    func regularFunction(a, b twoInts) twoInts {
        temp := twoInts{X: a.X + b.X, Y: a.Y + b.Y}
        return temp
    }
    func (a twoInts) method(b twoInts) twoInts {
        temp := twoInts{X: a.X + b.X, Y: a.Y + b.Y}
        return temp
    }
        i := twoInts{X: 1, Y: 2}
        j := twoInts{X: -5, Y: -2}
        fmt.Println(regularFunction(i, j))
        fmt.Println(i.method(j))


----------------------------------------------------------
Интерфейсы в Go

    Интерфейсный тип в Go определяет поведение других типов путем предоставле-
    ния списка методов, которые необходимо реализовать. Чтобы тип соответствовал
    интерфейсу, в нем необходимо реализовать все методы, предусмотренные этим
    интерфейсом

    Проще говоря, интерфейс — это абстрактный тип, определяющий множе-
    ство функций, которые необходимо реализовать для типа, чтобы его можно
    было считать экземпляром интерфейса. Если это сделано, можно сказать, что
    тип удовлетворяет данному интерфейсу. Таким образом, интерфейс — это две
    составляющие: набор методов и тип. Интерфейс используется для определения
    поведения других типов.

    io.Reader и io.Writer
    type Reader interface {
        Read(p []byte) (n int, err error)
    }
    type Writer interface {
        Write(p []byte) (n int, err error)
    }

----------------------------------------------------------
Операции утверждения типа    assertion.go   myInterface.go   useInterface.go

    Операции утверждения типа — это записи вида x.(T), где x — интерфейсный тип, а T — тип

    var myInt interface{} = 123
    k, ok := myInt.(int)
    if ok {
        fmt.Println("Success:", k)
    }

    $ mkdir ~/go/src/myInterface
    $ cp myInterface.go ~/go/src/myInterface
    $ go install myInterface

----------------------------------------------------------
Использование интерфейса Go    useInterface.go

    func (s circle) Area() float64 {
        return s.R * s.R * math.Pi
    }
    func (s circle) Perimeter() float64 {
        return 2 * s.R * math.Pi
    }
    func Calculate(x myInterface.Shape) {
        _, ok := x.(circle)
        if ok {
            fmt.Println("Is a circle!")
        }
        v, ok := x.(square)
        if ok {
            fmt.Println("Is a square:", v)
        }
        fmt.Println(x.Area())
        fmt.Println(x.Perimeter())
    }

    Как видим, в этом коде реализована функция, для которой требуется один пара-
    метр типа shape, — myInterface.Shape. Эта магия станет более очевидной, когда вы
    поймете, что здесь подойдет любой параметр типа shape, то есть любой параметр,
    тип которого реализует интерфейс shape

    x := square{X: 10}
    fmt.Println("Perimeter:", x.Perimeter())
    Calculate(x)
    y := circle{R: 5}
    Calculate(y)


----------------------------------------------------------
Использование переключателей для интерфейсов и типов данных    switch.go

    type rectangle struct {
        X float64
        Y float64
    }
    func tellInterface(x interface{}) {
        switch v := x.(type) {
        case square:
            fmt.Println("This is a square!")
        case circle:
            fmt.Printf("%v is a circle!\n", v)
        case rectangle:
            fmt.Println("This is a rectangle!")
        default:
            fmt.Printf("Unknown type %T!\n", v)
        }
    }
        y := rectangle{X: 4, Y: 1}
	    tellInterface(y)


----------------------------------------------------------
----------------------------------------------------------
Рефлексия

    Рефлексия — это дополнительная функциональность Go, которая позволяет дина-
    мически, в процессе выполнения программы, узнавать тип произвольного объекта,
    а также получать информацию о его структуре. Для работы с рефлексией в Go
    создан пакет reflect

----------------------------------------------------------
Простой пример рефлексии   reflection.go

    x := 100
	xRefl := reflect.ValueOf(&x).Elem()
	xType := xRefl.Type()
    =
    xType := reflect.TypeOf(x)

    var r reflect.Value
    r = reflect.ValueOf(&A).Elem()
        Типом переменной r должен быть reflect.Value, по-
        скольку функция reflect.ValueOf() возвращает значение именно этого типа. Метод
        Elem() возвращает значение, содержащееся в интерфейсе рефлексии (reflect.Value)

    iType := r.Type()
    for i := 0; i < r.NumField(); i++ {
        fmt.Printf("Field name: %s ", iType.Field(i).Name)
        fmt.Printf("with type: %s ", r.Field(i).Type())
        fmt.Printf("and value %v\n", r.Field(i).Interface())
    }
    функции пакета reflect: 
    Метод NumField() возвращает количество полей в структуре reflect.Value, а 
    функция Field() возвращает поле структуры, переданной ей в качестве параметра. 
    Функция Interface() возвращает значение поля структуры reflect.Value в качестве интерфейса

    $ go run reflection.go 1
    $ go run reflection.go

----------------------------------------------------------
Более сложный пример рефлексии    advRefl.go

    type t1 int
    type t2 int
        для Go t1 и t2 - это разные типы
        Их внутреннее представление будет main.t1 и main.t2 соответственно




стр. 343
