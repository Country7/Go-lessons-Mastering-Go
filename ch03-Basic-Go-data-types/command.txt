Работа с основными типами данных Go

----------------------------------------------------------
Числовые типы данных   numbers.go

Целые числа
  со знаком: int8, int16, int32, int64, кроме того int
  без знака: uint8, uint16, uint32 и uint64, кроме того uint

Числа с плавающей точкой: float32 и float64
Первый из них обеспечивает точность примерно до шестого знака после запятой, 
а второй — до 15-го знака

Комплексные числа: complex64 и complex128
В первом из них используется два типа float32: 
один для вещественной части комплексного числа, 
а второй — для мнимой, 
тогда как в complex128 используется два типа float64.
Комплексные числа выражаются в форме a + bi, где a и b — действительные 
числа, а i — решение уравнения x2(в квадрате) = –1

если разделить одно целое число на другое, то Go решит, что вы хотите 
получить результат целочисленного деления
При преобразовании числа с плавающей запятой в целое число дробь 
отбрасывается путем усечения числа с плавающей запятой до нуля 
знаков после запятой

% - остаток от деления двух чисел (модуль)

    $ go run numbers.go
    Type of c1: complex128
    Type of c2: complex128
    c3: (17+8i)
    Type of c3: complex64
    cZero: (0+0i)
    12
    Type of x: int
    div 2
    m, n: 1.223 0
    y: 1.7391304347826086
    divFloat 2.4
    Type of divFloat: float64


----------------------------------------------------------
Циклы Go

Цикл for
    for i := 0; i < 100; i++ {
        // break
        // continue
    }

    for ok := true; ok; ok = anExpression {
    }

    for condition {}

    range
    anArray := [5]int{0, 1, -1, 2, -2}
    for i, value := range anArray {
        fmt.Println("index:", i, "value: ", value)
    }

Пример применения нескольких циклов Go   loops.go
    $ go run loops.go


----------------------------------------------------------
Массивы в Go:   usingArrays.go
    anArray := [4]int{1, 2, 4, -4}

длина массива len(anArray)

Многомерные массивы:
    twoD := [4][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}
    threeD := [2][2][2]int{{{1, 0}, {-2, 4}}, {{5, -1}, {7, 0}}}

Недостатки массивов Go:
    - если массив определен, вы не можете изменить его размер
    - передавая массив функции в качестве параметра, вы передаете копию массива,
      так что любые изменения, внесенные в массив внутри функции, после выхода 
      из этой функции будут потеряны
    - передача большого массива в функцию — довольно медленная операция
    Решением всех этих проблем является использование срезов Go



----------------------------------------------------------
Срезы в Go

!!! Срезы Go — очень мощные структуры данных. Не будет преувеличением сказать,
    что срезы способны полностью заменить массивы в Go

!!! Срезы передаются в функции по ссылке — это означает, что фактически в функ-
    цию передается адрес памяти переменной среза

инициализация
    aSliceLiteral := []int{1, 2, 3, 4, 5}
    или
    integer := make([]int, 20)

доступ к срезу
    for i := 0; i < len(integer); i++ {
        fmt.Println(integer[i])
    }
    integer[0]  // первый элемент среза
    inte­ger[len(integer)-1]  // последний элемент среза
    integer[1:3]    // второй и третий элемент среза
    s2 := integer[1:3]  // новый (вторичный) срез

очистить срез
    aSliceLiteral = nil

добавить элемент к срезу
    integer = append(integer, 12345)

    $ go run reslice.go
    [0 0 0 0 0]
    [0 0]
    [0 -100 123456 0 0]
    [-100 123456]

!!! При изменении элементов вторичного среза изменяются и элементы исходного среза,
    поскольку оба они указывают на один и тот же базовый массив. Проще говоря, при
    создании вторичного среза не создается копия исходного среза.

----------------------------------------------------------
Автоматическое расширение срезов   lenCap.go

len()  Длина среза
cap()  Емкость среза
append()  добавить элемент к срезу

    $ go run lenCap.go
    aSlice: -1 0 4 
    Cap: 3, Length: 3
    aSlice: -1 0 4 -100 
    Cap: 6, Length: 4
    -1 0 4 -100 -2 -3 -4 
    Cap: 12, Length: 7

!!! Если длина и емкость среза имеют одинаковые значения, то попытка
    добавить в срез еще один элемент приводит к тому, что емкость среза будет
    удвоена, тогда как его длина увеличится только на единицу

!!! Нужно заметить, что емкость среза удваивается, только пока его длина не превысит
    1024 элементов. Далее она растет не более чем на 25 %

----------------------------------------------------------
Функция copy(dst, src)   copySlice.go

    $ go run copySlice.go
    a6: [-10 1 2 3 4 5]
    a4: [-1 -2 -3 -4]
    a6: [-1 -2 -3 -4 4 5]
    a4: [-1 -2 -3 -4]

    b6: [-10 1 2 3 4 5]
    b4: [-1 -2 -3 -4]
    b6: [-10 1 2 3 4 5]
    b4: [-10 1 2 3]

    array4: [4 -4 4 -4]
    s6: [4 -4 4 -4 5 -5]

    array5: [7 7 -7 -7 7]
    s7: [7 7 -7 -7 7 -7 7]

----------------------------------------------------------
Многомерные срезы   slices.go

    $ go run slices.go
    [1 2 3 4 5]
    [0 0]
    []
    [-1 -2 -3 -4 -5]
    [-1 -2 -3 -4 -5]
    [-1 -2 -3 -4 -100]
    [0 0 0 0 0]
    [[] [] []]
    i: 0 value: 0
    i: 1 value: 0
    i: 0 value: 0
    i: 1 value: 1
    i: 0 value: 0
    i: 1 value: 2

!!! объекты двумерного среза инициализируются значениями nil и 
    поэтому выводятся как пустые; это происходит потому, что нулевое
    значение для типа среза равно nil

----------------------------------------------------------
Сортировка срезов с помощью sort.Slice()   sortSlice.go

    $ go run sortSlice.go
    0: [{Mihalis 180 90} {Bill 134 45} {Marietta 155 45} {Epifanios 144 50} {Athina 134 40}]
    <: [{Bill 134 45} {Athina 134 40} {Epifanios 144 50} {Marietta 155 45} {Mihalis 180 90}]
    >: [{Mihalis 180 90} {Marietta 155 45} {Epifanios 144 50} {Bill 134 45} {Athina 134 40}]

----------------------------------------------------------
Добавление массива к срезу   appendArrayToSlice.go

    ref := a[:]
    t := append(s, ref...)

    $ go run appendArrayToSlice.go
    Existing array:  [4 5 6]
    New slice:       [1 2 3 4 5 6]
    Existing slice:  [1 2 3 4 5 6]
    s+s:             [1 2 3 4 5 6 1 2 3 4 5 6]



----------------------------------------------------------
Хеш-таблицы Go  (или карты (map))   usingMaps.go

!!! способность использовать любой тип данных в качестве индекса
    iMap = make(map[string]int)

    anotherMap := map[string]int {
        "k1": 12
        "k2": 13
    }

    delete(anotherMap, "k1")

    for key, value := range iMap {
        fmt.Println(key, value)
    }

    $ go run usingMaps.go
    iMap: map[k1:12 k2:13]
    anotherMap: map[k1:12 k2:13]
    anotherMap: map[k2:13]
    Does NOT exist
    k1 12
    k2 13

----------------------------------------------------------
Запись в хеш-таблицу со значением nil

!!! вставить данные в хеш-таблицу со значением nil не получится. 
    Однако поиск, удаление, определение длины и использование циклов range для
    хеш-таблицы со значением nil не приведут к краху кода


----------------------------------------------------------
Константы Go   (const)

    const HEIGHT = 200
    const (
        C1 = "C1C1C1"
        C2 = "C2C2C2"
        C3 = "C3C3C3"
    )

не являются константой:
    s1 := "My String"
    var s2 = "My String"
    var s3 string = "My String"

являются константами:
    const s1 = "My String"
    const s2 string = "My String"

----------------------------------------------------------
Генератор констант iota    constants.go

!!!  << используется для «умножить на 2» и >> для «разделить на 2» 
    и число после него - сколько раз.
    То же самое n << x и «n умножить на 2, x раз». 
    И y >> z "y деить на 2, z раз".

    $ go run constants.go
    1476
    3.1415926
    1
    2
    2^0: 1
    2^2: 4
    2^4: 16
    2^6: 64


----------------------------------------------------------
Указатели в Go    pointers.go

получить значение указателя - *, которая называется разыменованием указателя
оператор &, чтобы получить адрес памяти переменной

Чтобы функция принимала указатель в качестве параметра, нужно написать:
    func getPointer(n *int) {
    }
Аналогичным образом функция может возвращать указатель:
    func returnPointer(n int) *int {
    }

!!! ++ (increment) and -- (decrement) operators

    $ go run pointers.go
    pI memory: 0xc0000180f0
    pJ memory: 0xc0000180f8
    pI value: -10
    pJ value: 25
    i: 123455
    j: 625
    144
    0xc000018128

!!! строки в Go являются переменными, хранящими значение, а не указателями, как в C


----------------------------------------------------------
----------------------------------------------------------
Время и дата   пакет time    usingTime.go

time.Now().Unix() возвращает время эпохи UNIX — количество секунд,
    прошедших с 00:00:00 UTC 1 января 1970 года

time.Format() позволяет преобразовывать переменную типа time в другой формат, 
    в данном случае в формат RFC3339

time.Sleep(), позволяющая эмулировать задержку

time.Second - 1 секунда
    time.Nanosecond, time.Microsecond , time.Millisecond , time.Minute и time.Hour

time.Sub() вычисляет разность между двумя значениями времени

    $ go run usingTime.go
    Epoch time: 1687781557
    2023-06-26 15:12:37.266653016 +0300 MSK m=+0.000036428 2023-06-26T15:12:37+03:00
    Monday 26 June 2023
    Time difference: 1.000283133s
    06 June 2023
    Paris: 2023-06-26 14:12:37.266653016 +0200 CEST

----------------------------------------------------------
Работа с временем и датами

time.Parse()
    формат синтаксического анализа дат: https://golang.org/src/time/format.go

Синтаксический анализ времени   parseTime.go
    $ go run parseTime.go 12:20
    Full: 0000-01-01 12:20:00 +0000 UTC
    Time: 12 20

Синтаксический анализ дат   parseDate.go
    $ go run parseDate.go "20 July 2023"
    Full: 2023-07-20 00:00:00 +0000 UTC
    Time: 20 July 2023

Изменение формата даты и времени    timeDate.go
    пакет Go regexp необходим для поддержки регулярных выражений

    $ go run timeDate.go
    Thursday, 16-Nov-17 10:49:46 +0200
    Thursday, 16-Nov-17 10:16:41 +0200
    Sunday, 12-Nov-17 06:26:05 +0200
    Sunday, 12-Nov-17 16:27:21 MSK
    Not a valid date time format!
    Not a match!

----------------------------------------------------------
Измерение времени выполнения программы    execTime.go 

time.Since()   один аргумент, который должен означать момент времени в прошлом
    duration := time.Since(start)

    $ go run execTime.go
    It took time.Sleep(1) 1.000152671s to finish.
    It took time.Sleep(2) 2.001153616s to finish.
    It took the for loop 107.94656ms to finish.
    It took the for loop 73.675711ms to finish.


----------------------------------------------------------
Измерение скорости работы сборщика мусора Go
    sliceGCTime.go, mapNoStarTime.go, mapStarTime.go и mapSplitTime.go

    $ go run sliceGCTime.go
    It took GC() 11.92446ms to finish
    $ go run mapNoStarTime.go
    It took GC() 15.133376ms to finish
    $ go run mapStarTime.go
    It took GC() 995.945581ms to finish    // медленно сборщик мусора работает с хеш-таблицами
    $ go run mapSplitTime.go
    It took GC() 34.509111ms to finish




