Как улучшить код Go с помощью структур данных

----------------------------------------------------------
О графах и узлах

    Граф (G (V, E)) — это конечное непустое множество вершин (или узлов) V и множество ребер E
    Циклический граф — это граф, в котором все или некоторые вершины образуют замкнутый контур
    В ациклических графах замкнутых контуров нет
    Направленный граф — это граф, с ребрами которого связано некое направление
    Направленный ациклический граф — это направленный граф без замкнутых контуров

----------------------------------------------------------
Сложность алгоритма

    Лучший алгоритм со сложностью O(n)
    Худший - O(n!) - практически непригодным для случаев, когда объем
                     входных данных насчитывает более чем 300 элементов
    Операции поиска для встроенных типов - O(1) - работают быстрее


----------------------------------------------------------
----------------------------------------------------------
Двоичные деревья в Go

    Двоичное дерево — это структура данных, в которой под каждым узлом распо-
    лагается не более двух других узлов

    Корень дерева
    Глубина дерева
    Высота дерева
    Глубина узла
    Лист
    Сбалансированное дерево
    Несбалансированное дерево

Реализация двоичного дерева в Go     binTree.go

    type Tree struct {
        Left    *Tree
        Value   int
        Right   *Tree
    }

Преимущества двоичных деревьев:
    Высота сбалансированного дерева из 1 000 000 элементов — около 20,
    можем достичь любого узла дерева из 1 000 000 узлов менее чем за 20 шагов!

Недостатки двоичных деревьев:
    Если у дерева длинные и сложные ключи, то вставка или поиск элемента могут о
    казаться медленными из-за большого количества требуемых операций сравнения. 
    Наконец, если дерево не сбалансировано, то скорость выполняемых в нем операций 
    будет непредсказуемой


----------------------------------------------------------
----------------------------------------------------------
Пользовательские хеш-таблицы в Go    hashTable.go 

    type Node struct {
        Value int
        Next *Node
    }  - определение узла пользовательской хеш-таблицы

    type HashTable struct {
        Table map[int]*Node
        Size int
    }

    Основная причина, по которой для хранения связных списков хеш-таблицы
    использована хеш-таблица Go, а не срез или массив, заключается в том, что ключи
    среза или массива могут быть только положительными целыми числами, а ключи
    хеш-таблицы Go могут быть практически любыми.

    способ вывода пар «ключ — значение» для хеш-таблицы Go
    является преднамеренно абсолютно случайным, поэтому на него нельзя полагаться

Реализация функции поиска   hashTableLookup.go

    func lookup(hash *HashTable, value int) bool {
        index := hashFunction(value, hash.Size)
        if hash.Table[index] != nil {
            t := hash.Table[index]
            for t != nil {
                if t.Value == value {
                    return true
                }
                t = t.Next
            }
        }
        return false
    }


----------------------------------------------------------
Связные списки в Go   linkedList.go

    type Node struct {
        Value int
        Next  *Node
    }

    var root = new(Node)

    Самым большим преимуществом связных списков является то, что они просты для
    понимания и реализации и достаточно универсальны, чтобы их можно было ис-
    пользовать в разных ситуациях. Связные списки применяются для моделирования
    различных типов данных, начиная с отдельных значений и заканчивая сложными
    структурами со многими полями. Кроме того, в связных списках очень быстро вы-
    полняется последовательный поиск с помощью указателей.

Двусвязные списки в Go   doublyLList.go

    type Node struct {
        Value    int
        Previous *Node
        Next     *Node
    }

    Двунаправленные связные списки более универсальны, чем односвязные, по-
    скольку по ним можно перемещаться в любом направлении, в них легче вставлять
    и удалять элементы. Кроме того, даже если вы потеряете указатель на заголовок
    двусвязного списка, то все равно сможете найти головной узел такого списка.


----------------------------------------------------------
Очереди в Go   queue.go

    type Node struct {
        Value int
        Next  *Node
    }

    var size = 0
    var queue = new(Node)


----------------------------------------------------------
Стеки в Go   stack.go

    Стек — это структура данных, которая похожа на стопку тарелок: когда вам пона-
    добится новая тарелка, вы возьмете верхнюю.

    type Node struct {
        Value int
        Next  *Node
    }

    var size = 0
    var stack = new(Node)


----------------------------------------------------------
----------------------------------------------------------
Пакет container   

    поддерживает три структуры данных: кучу, список и кольцо
    container/heap
    container/list
    container/ring

----------------------------------------------------------
Использование пакета container/heap   conHeap.go

    пакет container/heap реализует кучу — дерево, где
    значение каждого узла является наименьшим элементом в его поддереве. 
    Выражение «наименьший элемент» вместо «минимальное
    значение», чтобы подчеркнуть, что куча поддерживает не только числовые значения.
    Для того чтобы реализовать дерево кучи в Go, не-
    обходимо самостоятельно разработать способ, позволяющий определить, какой из
    двух элементов меньше. В таких случаях в Go используются интерфейсы, которые
    позволяют определять такое поведение

    Строго говоря, пакет
    container/heap требует реализации container/heap.Interface, который определя-
    ется следующим образом:

    type Interface interface {
        sort.Interface
        Push(x interface{})  // вставляет x как элемент Len()
        Pop() interface{}    // удаляет и возвращает элемент Len() - 1
    }

    Для sort.Interface необходимо реализовать функции Len(), Less() и Swap()

    но если нужно хранить в куче
    указатели, то при извлечении его из кучи нужно не забывать обнулять место его хранения,
    например, так: old[len(old) – 1] = nil. В противном случае сборщик мусора не сможет
    очистить место под объект, на который указывает извлеченный из кучи указатель.

    для того чтобы восстановить правильную
    упорядоченность кучи, нужно снова вызвать heap.Init()
    В приведенном примере для добавления в кучу использовалась функция myHeap.Push(),
    которая не поддерживает упорядоченность кучи. Это и привело к необходимости по-
    вторной инициации кучи функцией heap.Init(). Для автоматического поддержания
    упорядоченности кучи лучше использовать функцию heap.Push().

----------------------------------------------------------
Использование пакета container/list   conList.go

    Функции Prev() и Next() позволяют перебирать элементы списка
    в прямом и обратном порядке

    Функция list.PushBack() позволяет вставлять объект в конец связного списка,
    а функция list.PushFront() — в начало списка. Обе функции возвращают встав-
    ленный в список элемент

    вставить новый элемент после определенного элемента, то
    следует использовать функцию list.InsertAfter(). Аналогично, для того чтобы
    вставить элемент перед конкретным элементом, необходимо применить функцию
    list.InsertBefore()
    Если такой элемент не существует, то список не изменится.

    Функция list.PushBackList() вставляет копию существующего списка в конец дру-
    гого списка, а list.PushFrontList() помещает копию существующего списка в на-
    чало другого списка. Функция list.Remove() удаляет из списка заданный элемент.
    Обратите внимание на использование функции values.Init(), которая либо
    очищает существующий список, либо инициализирует новый список.

----------------------------------------------------------
Использование пакета container/ring   conRing.go

    мы можем вызывать ring.Next()
    до бесконечности, поэтому нужно найти способ, как это прекратить. В данном
    случае это сделано с помощью функции ring.Len(). Я предпочитаю использовать
    для перебора всех элементов кольца функцию ring.Do(), поскольку она генерирует
    более чистый код, но использовать цикл for тоже неплохо.


----------------------------------------------------------
----------------------------------------------------------
Генерация случайных чисел   randomNumbers.go

    В Go для генерации псевдослучайных чисел применяется пакет math/rand. Чтобы
    начать генерировать числа, нужно начальное число. Начальное число используется
    для инициализации всего процесса и имеет важное значение, поскольку если всегда
    начинать с одного и того же числа, то мы будем получать одну и ту же последова-
    тельность псевдослучайных чисел. Это означает, что данную последовательность
    сможет восстановить любой желающий и она в итоге не будет случайной.

----------------------------------------------------------
Генерация случайных строк   generatePassword.go

    в консоли команда man ascii покажет таблицу символов

----------------------------------------------------------
Генерация безопасной последовательности случайных чисел   cryptoRand.go

    Если вы хотите генерировать на Go более безопасные псевдослучайные числа,
    следует использовать пакет crypto/rand, в котором реализован криптографически
    безопасный генератор псевдослучайных чисел


----------------------------------------------------------
----------------------------------------------------------
Выполнение матричных вычислений

    Есть несколько правил, которые позволяют определить, можно ли выполнять
    вычисления между двумя матрицами:
    - при сложении или вычитании обе матрицы должны иметь одинаковые размеры;
    - при умножении матрицы A на матрицу B количество столбцов матрицы A долж-
    но быть равно количеству строк матрицы B. В противном случае умножение
    матриц A и B невозможно;
    - при делении матрицы A на матрицу B должны быть выполнены два условия.
    Во-первых, необходимо, чтобы у матрицы B существовала обратная матрица,
    а во-вторых, должна быть возможность умножить матрицу A на обратную
    матрицу B в соответствии с предыдущим правилом. Обратные матрицы суще-
    ствуют только у квадратных матриц.

----------------------------------------------------------
Сложение и вычитание матриц   addMat.go

    func addMatrices(m1 [][]int, m2 [][]int) [][]int {
        result := make([][]int, len(m1))
        for i, x := range m1 {
            for j, _ := range x {
                result[i] = append(result[i], m1[i][j]+m2[i][j])
            }
        }
        return result
    }

----------------------------------------------------------
Умножение матриц   mulMat.go

    func multiplyMatrices(m1 [][]int, m2 [][]int) ([][]int, error) {
        if len(m1[0]) != len(m2) {
            return nil, errors.New("Cannot multiply the given matrices!")
        }
        result := make([][]int, len(m1))
        for i := 0; i < len(m1); i++ {
            result[i] = make([]int, len(m2[0]))
            for j := 0; j < len(m2[0]); j++ {
                for k := 0; k < len(m2); k++ {
                    result[i][j] += m1[i][k] * m2[k][j]
                }
            }
        }
        return result, nil
    }

----------------------------------------------------------
Деление матриц   divMat.go

    Функции getCofactor() и determinant() вычисляют элементы, необходимые
    для обращения матрицы. Если определитель матрицы равен 0, то матрица является
    сингулярной
    Функция adjoint() вычисляет сопряженную матрицу для исходной матрицы.
    Функция inverseMatrix() вычисляет обратную матрицу для исходной матрицы.
    Функция multiplyMatrices() нужна нам потому, что разделить одну матрицу
    на другую — это все равно что умножить первую матрицу на матрицу, обратную
    второй.

----------------------------------------------------------
Как определить размеры массива   dimensions.go

----------------------------------------------------------
Разгадывание головоломок судоку   sudoku.go

    $ go run sudoku.go OK.txt
    Correct Sudoku puzzle!
    $ go run sudoku.go noOK1.txt
    Incorrect Sudoku puzzle!

